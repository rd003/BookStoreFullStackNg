{
  "version": 3,
  "sources": ["../../../../../node_modules/@ngrx/operators/fesm2022/ngrx-operators.mjs"],
  "sourcesContent": ["import { of, EMPTY } from 'rxjs';\nimport { concatMap, withLatestFrom, map, catchError, tap, finalize } from 'rxjs/operators';\n\n/**\n * `concatLatestFrom` combines the source value\n * and the last available value from a lazily evaluated Observable\n * in a new array\n *\n * @usageNotes\n *\n * Select the active customer from the NgRx Store\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/operators';\n * import * as fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom(() => this.store.select(fromCustomers.selectActiveCustomer))\n * )\n * ```\n *\n * Select a customer from the NgRx Store by its id that is available on the action\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/operators';\n * import * fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom((action) => this.store.select(fromCustomers.selectCustomer(action.customerId)))\n * )\n * ```\n */\nfunction concatLatestFrom(observablesFactory) {\n  return concatMap(value => {\n    const observables = observablesFactory(value);\n    const observablesAsArray = Array.isArray(observables) ? observables : [observables];\n    return of(value).pipe(withLatestFrom(...observablesAsArray));\n  });\n}\n\n/**\n * `mapResponse` is a map operator with included error handling.\n * It is similar to `tapResponse`, but allows to map the response as well.\n *\n * The main use case is for NgRx Effects which requires an action to be dispatched.\n *\n * @usageNotes\n * ```ts\n * export const loadAllUsers = createEffect((\n *   actions$ = inject(Actions),\n *   usersService = inject(UsersService)\n * ) => {\n *   return actions$.pipe(\n *     ofType(UsersPageActions.opened),\n *     exhaustMap(() => {\n *       return usersService.getAll().pipe(\n *         mapResponse({\n *           next: (users) => UsersApiActions.usersLoadedSuccess({ users }),\n *           error: (error) => UsersApiActions.usersLoadedFailure({ error }),\n *         })\n *       );\n *     })\n *   );\n * });\n * ```\n */\nfunction mapResponse(observer) {\n  return source$ => source$.pipe(map(value => observer.next(value)), catchError(error => of(observer.error(error))));\n}\n\n/**\n * Handles the response in ComponentStore effects in a safe way, without\n * additional boilerplate. It enforces that the error case is handled and\n * that the effect would still be running should an error occur.\n *\n * Takes optional callbacks for `complete` and `finalize`.\n *\n * @usageNotes\n *\n * ```ts\n * readonly dismissAlert = this.effect<Alert>((alert$) => {\n *   return alert$.pipe(\n *     concatMap(\n *       (alert) => this.alertsService.dismissAlert(alert).pipe(\n *         tapResponse(\n *           (dismissedAlert) => this.alertDismissed(dismissedAlert),\n *           (error: { message: string }) => this.logError(error.message)\n *         )\n *       )\n *     )\n *   );\n * });\n *\n * readonly loadUsers = this.effect<void>((trigger$) => {\n *   return trigger$.pipe(\n *     tap(() => this.patchState({ loading: true })),\n *     exhaustMap(() =>\n *       this.usersService.getAll().pipe(\n *         tapResponse({\n *           next: (users) => this.patchState({ users }),\n *           error: (error: HttpErrorResponse) => this.logError(error.message),\n *           finalize: () => this.patchState({ loading: false }),\n *         })\n *       )\n *     )\n *   );\n * });\n * ```\n */\nfunction tapResponse(observerOrNext, error, complete) {\n  const observer = typeof observerOrNext === 'function' ? {\n    next: observerOrNext,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    error: error,\n    complete\n  } : observerOrNext;\n  return source => source.pipe(tap({\n    next: observer.next,\n    complete: observer.complete\n  }), catchError(error => {\n    observer.error(error);\n    return EMPTY;\n  }), observer.finalize ? finalize(observer.finalize) : source$ => source$);\n}\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { concatLatestFrom, mapResponse, tapResponse };\n"],
  "mappings": ";;;;;;;;;;;;;;AAgCA,SAAS,iBAAiB,oBAAoB;AAC5C,SAAO,UAAU,WAAS;AACxB,UAAM,cAAc,mBAAmB,KAAK;AAC5C,UAAM,qBAAqB,MAAM,QAAQ,WAAW,IAAI,cAAc,CAAC,WAAW;AAClF,WAAO,GAAG,KAAK,EAAE,KAAK,eAAe,GAAG,kBAAkB,CAAC;AAAA,EAC7D,CAAC;AACH;AA4BA,SAAS,YAAY,UAAU;AAC7B,SAAO,aAAW,QAAQ,KAAK,IAAI,WAAS,SAAS,KAAK,KAAK,CAAC,GAAG,WAAW,WAAS,GAAG,SAAS,MAAM,KAAK,CAAC,CAAC,CAAC;AACnH;AAyCA,SAAS,YAAY,gBAAgB,OAAO,UAAU;AACpD,QAAM,WAAW,OAAO,mBAAmB,aAAa;AAAA,IACtD,MAAM;AAAA;AAAA,IAEN;AAAA,IACA;AAAA,EACF,IAAI;AACJ,SAAO,YAAU,OAAO,KAAK,IAAI;AAAA,IAC/B,MAAM,SAAS;AAAA,IACf,UAAU,SAAS;AAAA,EACrB,CAAC,GAAG,WAAW,CAAAA,WAAS;AACtB,aAAS,MAAMA,MAAK;AACpB,WAAO;AAAA,EACT,CAAC,GAAG,SAAS,WAAW,SAAS,SAAS,QAAQ,IAAI,aAAW,OAAO;AAC1E;",
  "names": ["error"]
}
